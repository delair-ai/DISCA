# -*- coding: utf-8 -*-
"""
/***************************************************************************
 InteractLearn
                                 A QGIS plugin
 Framework to test the algos designed during my PhD
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-04-16
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Gaston Lenczner
        email                : gaston.lenczner@delair.aero
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from os import path
from functools import partial

from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import QShortcut

from qgis.core import (Qgis, QgsApplication, QgsField, QgsFields, QgsProject,
                       QgsRasterLayer, QgsTask, QgsVectorFileWriter,
                       QgsVectorLayer, QgsWkbTypes)
from qgis.PyQt.QtCore import QVariant

from .set_points import SetPoints
from .core import QgsCorePlugin
from .dialogs import InteractLearnDialog, SaveNetworkDialog
from .utils import (WarnQgs, client_to_server, file_in_layers, get_layers,
                    raster_to_file, set_renderer_raster, set_renderer_vector)




class InteractLearn(QgsCorePlugin):
    def __init__(self, iface):
        super().__init__(iface)
        # Will contain the different files used to send to the daemon and the crop coordinates
        self.files = {"polygonize": None, "annot_layer": None}
        self.task = None
        self.dlg = None
        self.n_classes = None
        self.map_tool = None
        self.extent = None

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = "frontend/icons/wow.png"
        icon_nn_path = "frontend/icons/nn_.png"
        icon_click_path = "frontend/icons/point.png"
        icon_save_net_path = "frontend/icons/save_net.png"
        self.add_action(
            icon_path,
            text=self.tr("Set neural network"),
            callback=self.gui_dialog,
            parent=self.iface.mainWindow(),
            shortcut="F6",
        )
        self.add_action(
            icon_nn_path,
            text=self.tr("Inference (F4)"),
            callback=self.infer_only,
            parent=self.iface.mainWindow(),
            shortcut="F4",
        )
        self.add_action(
            icon_click_path,
            text=self.tr("Annotate"),
            callback=self.clicky,
            parent=self.iface.mainWindow(),
        )
        self.add_action(
            icon_save_net_path,
            text=self.tr("Save network"),
            callback=self.save_network,
            parent=self.iface.mainWindow(),
        )

        short = QShortcut("F3", self.iface.mainWindow())
        short.setContext(Qt.ApplicationShortcut)
        short.activated.connect(partial(self._set_class_annot))

    def gui_dialog(self):
        """Interact with the user with the GUI"""

        self.dlg = InteractLearnDialog(self.iface)
        if self.first_start:
            if not QgsProject.instance().layerTreeRoot().findLayers():
                WarnQgs(
                    "Please load at least one layer to launch this segmentation plugin.",
                    self.iface,
                )(Qgis.Critical)
                return

            layers, layers_names = get_layers()
            idx = layers.index(self.iface.activeLayer())
            self.dlg.sub_dlg.listWidget.item(idx).setSelected(True)
            self.dlg.textEdit.setText(str(layers_names[idx]) + "\n")
        else:
            self.dlg.init_from_previous_state(self.files)

        self.dlg.show()
        self.dlg.finished.connect(self.dialog_finished)

    def dialog_finished(self, status):
        """Launched once the GUI is closed.
         - Load all the data from pyqt objects
         -  check their integrity
         - Ends calling the daemon with `self.qgs_task`.
        """
        if self.dlg.map_tool:
            self.iface.mapCanvas().unsetMapTool(self.dlg.map_tool)
        if status:
            self.first_start = False
            self._load_data()
            msg = self._check_data()
            if msg:
                WarnQgs(msg, self.iface)(Qgis.Critical)
                return
            self.qgs_task()

    def infer_only(self):
        """Calls `self.qgs_task` with the same parameters than `self.dialog_finished`."""
        if self.dlg is None:
            WarnQgs(
                "Set parameters for inference first with the `IL` button", self.iface
            )(Qgis.Warning)
        else:
            self.files["reset"] = False
            self.files["reset_network"] = False
            self.qgs_task()

    def qgs_task(self):
        """Send data to daemon and activate it."""
        load_qgs = bool(file_in_layers(self.files["output_file"]))
        self._set_annot_lyr(load=load_qgs)
        # send data to daemon
        WarnQgs("Neural network magic in the background", self.iface)(level=Qgis.Info)
        task = QgsTask.fromFunction(
            "Neural network",
            client_to_server,
            on_finished=self._completed,
            data=self.files,
            task_="segmentation"
        )
        QgsApplication.taskManager().addTask(task)
        self.task = (
            task
        )  # necessary to keep a pointer on task to activate on_finished function.

    def save_network(self):
        if "refined_net_file" in self.files:
            default_filename = self.files["refined_net_file"]
        else:
            default_filename = self.files["neural_network"].replace('.', '_refined.') if "neural_network" in self.files else ''
        dlg = SaveNetworkDialog(default_filename)
        dlg.show()
        result = dlg.exec_()
        if result:
            self.files["refined_net_file"] = dlg.lineEdit.text()
            task = QgsTask.fromFunction(
                "Neural network",
                client_to_server,
                data=self.files,
                on_finished=self._print_save_network,
                task_="save_network",
            )
            QgsApplication.taskManager().addTask(task)
            self.task = (task)  # necessary to keep a pointer on task to activate on_finished function.

    def _print_save_network(self, exception, result=None):
        if exception is not None:
            if isinstance(exception, ConnectionRefusedError):
                msg = "Daemon not running. If it's running using ssh, check the ssh information in connexion_setup.yml"
            else:
                msg = f"{exception}"
            WarnQgs(msg, self.iface)(Qgis.Critical)
            return
        if result:
            WarnQgs("Success: Refined network saved.", self.iface)(Qgis.Info)
        else:
            WarnQgs("Failed: Refined network not saved.", self.iface)(Qgis.Critical)

    def clicky(self):
        """To make the clicks."""
        if self.first_start:
            WarnQgs("Make at least one inference before annotating.", self.iface)(
                level=Qgis.Warning
            )
            return
        self._set_annot_lyr()
        layer = self.iface.activeLayer()

        ### Annotation dialog
        self.map_tool = SetPoints(self.iface, layer)
        result = self.map_tool.set_class()
        if result:
            left_test = (
                self.map_tool.id_class_left < 0
                or self.map_tool.id_class_left >= self.n_classes
            )
            right_test = (
                self.map_tool.id_class_right < 0
                or self.map_tool.id_class_right >= self.n_classes
            )
            if left_test or right_test:
                WarnQgs(
                    f"Set valid class ids (between 0 and {self.n_classes - 1}).",
                    self.iface,
                )(Qgis.Critical)
                return
            self._set_class_annot()

    def _load_data(self):
        """Load data into `self.files` from pyqt objects"""
        self.files["input_files"] = raster_to_file(
            self.dlg.sub_dlg.listWidget.selectedItems()
        )
        self.files["output_file"] = self.dlg.line_output.text()
        self.files["neural_network"] = self.dlg.line_nn.text()
        if self.dlg.checkBox_geojson.isChecked():
            self.files["polygonize"] = (
                self.dlg.line_output.text().split(".")[0] + ".geojson"
            )
        else:
            self.files["polygonize"] = False
        self.files["interactive"] = self.dlg.checkBox_interactive.isChecked()
        self.files["interact_use_annots"] = self.dlg.checkBox_use_annot.isChecked()
        self.files["ssh"] = self.dlg.checkBox_ssh.isChecked()
        self.files["CL"] = self.dlg.checkBox_cl.isChecked()
        self.files["reset"] = self.dlg.checkBox_reset_annots.isChecked()
        self.files["reset_network"] = self.dlg.checkBox_reset_network.isChecked()
        if self.files["reset"]:
            self._set_annot_lyr(overwrite=True) # reset annotation layer
        d = {}
        d["reg_L1"] = self.dlg.dlg_cl.comboBox.currentText() == "L1"
        d["weight_reg"] = self.dlg.dlg_cl.spinBox_weight.value()
        d["steps"] = self.dlg.dlg_cl.spinBox.value()
        d["only_new_points"] = self.dlg.dlg_cl.checkBox.isChecked()
        self.files["cl_options"] = d
        del d

        layers, layers_names = get_layers()
        idx_input_lyr = layers_names.index(self.dlg.sub_dlg.listWidget.selectedItems()[0].text())
        self.extent = layers[idx_input_lyr].extent() # extent of the input

    def _check_data(self):
        """Check if files are consistent"""
        msg = ""
        for lyr in [file_in_layers(i) for i in self.files['input_files']]:
            if not isinstance(lyr, QgsRasterLayer):
                msg += f"Expect only raster layers as inputs.\n"
                break
        if not path.isfile(self.files["neural_network"]):
            msg += "The provided filename for the neural network does not exist.\n"
        if not path.exists(path.dirname(self.files["output_file"])):
            msg += "The provided directory for the output does not exist.\n"
        if path.isdir(self.files["output_file"]):
            msg += "Provide a filename for the output instead of a directory.\n"
        if '.' in self.files["output_file"]:
            if not (self.files["output_file"].endswith(".tiff") or self.files["output_file"].endswith(".tif")):
                msg += "Only Geotiff format accepted for the output (.tif)\n"
        else:
            self.files["output_file"] += ".tif"
        if self.files["output_file"] in self.files['input_files']:
            msg += "The output file is the same than an input file."
        return msg

    def _set_annot_lyr(self, overwrite=False, load=True):
        """load annotation layer (create it if it doesn't exist).
            overwrite: bool  overwrite annotation file if set to True
            load: bool  load layer in qgis
            """
        name = self.files["output_file"].split(".")[0] + ".shp"
        if  self.files["annot_layer"] != name:
            self.files["annot_layer"] = name
            
        if not path.isfile(name) or overwrite:
            fields = QgsFields()
            fields.append(QgsField("class", QVariant.Int))
            crs = file_in_layers(self.files["input_files"][0]).crs()
            QgsVectorFileWriter(
                name,
                "UTF-8",
                fields,
                QgsWkbTypes.Point,
                crs,
                driverName="ESRI Shapefile",
            )

        if load:
            lyr = file_in_layers(name)
            if lyr:
                self.iface.setActiveLayer(lyr)
            else:
                name_lyr = '_'.join(["annots", path.splitext(path.basename(self.files["annot_layer"]))[0]])
                lyr = QgsVectorLayer(name, name_lyr, "ogr")
                QgsProject.instance().addMapLayer(lyr)
            if self.n_classes is not None:
                set_renderer_vector(lyr, self.n_classes)
       

    def _set_class_annot(self):
        """set annotation tool"""
        if self.map_tool is None:
            WarnQgs("Set annotations classes before using this shortcut.", self.iface)(
                Qgis.Warning
            )
        else:
            self.iface.mapCanvas().setMapTool(self.map_tool)

    def _completed(self, exception, result=None):
        """Executed on_finished, i.e. when receiving an answer from the daemon."""
        if exception is not None:
            if isinstance(exception, ConnectionRefusedError):
                msg = "Daemon not running. If it's running using ssh, check the ssh information in connexion_setup.yml"
            else:
                msg = f"See server logs: {exception}"
            WarnQgs(msg, self.iface)(Qgis.Critical)
            return
        if isinstance(result, str):
            WarnQgs(result, self.iface)(level=Qgis.Warning)
        elif isinstance(result, int):
            # daemon returns the number of classes
            self.n_classes = result
            self.iface.mapCanvas().refreshAllLayers()
            f = (
                self.files["polygonize"]
                if self.files["polygonize"]
                else self.files["output_file"]
            )
            if not file_in_layers(f):
                if self.files["polygonize"]:
                    self.iface.addVectorLayer(self.files["polygonize"], "", "ogr")
                    active_layer = self.iface.activeLayer()
                    set_renderer_vector(active_layer, self.n_classes)
                else:
                    layer_name = path.basename(self.files["output_file"]).split(".")[0]
                    self.iface.addRasterLayer(self.files["output_file"], layer_name)
                    active_layer = self.iface.activeLayer()
                    active_layer.setExtent(self.extent)  # necessary if the output file has been deleted for some reason
                    set_renderer_raster(active_layer, self.n_classes)
            self._set_annot_lyr()
        else:
            WarnQgs("Wrong output type. Expect str or WarnQgs.", self.iface)(
                Qgis.Critical
            )
            return

